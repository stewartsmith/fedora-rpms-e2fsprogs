# HG changeset patch
# User tytso@mit.edu
# Date Sun Oct 22 00:18:49 2006 -0400
# Node ID 91cc4c459889b6013c832477742dc80274cca2e3
# parent: fa7a505b350d10ab97de18f5caeef0a8493dba94
Add failsafe against duplicate UUID's generated by threaded programs

Add in randomness based on Linux's thread id (gettid) to avoid race
conditions when two threads try to generate uuid's at the same time.
This shouldn't be an issue if /dev/urandom has proper locking and is
present, so this is just a failsafe.

Addresses SourceForge Bug: #1529672

Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

--- a/ChangeLog	Sun Oct 22 00:14:26 2006 -0400
+++ b/ChangeLog	Sun Oct 22 00:18:49 2006 -0400
@@ -0,0 +1,4 @@
+2006-10-22  Theodore Tso  <tytso@mit.edu>
+
+	* configure, configure.in: Add test for jrand48()
+
--- a/configure	Sun Oct 22 00:14:26 2006 -0400
+++ b/configure	Sun Oct 22 00:18:49 2006 -0400
@@ -16306,7 +16306,8 @@
 
 
 
-for ac_func in chflags getrusage llseek lseek64 open64 fstat64 getmntinfo strtoull strcasecmp srandom fchown mallinfo fdatasync strnlen strptime sysconf pathconf posix_memalign memalign valloc __secure_getenv prctl
+
+for ac_func in chflags getrusage llseek lseek64 open64 fstat64 getmntinfo strtoull strcasecmp srandom jrand48 fchown mallinfo fdatasync strnlen strptime sysconf pathconf posix_memalign memalign valloc __secure_getenv prctl
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 { echo "$as_me:$LINENO: checking for $ac_func" >&5
--- a/configure.in	Sun Oct 22 00:14:26 2006 -0400
+++ b/configure.in	Sun Oct 22 00:18:49 2006 -0400
@@ -659,7 +659,7 @@
 	[#include <sys/types.h>
 	 #include <sys/socket.h>])
 dnl
-AC_CHECK_FUNCS(chflags getrusage llseek lseek64 open64 fstat64 getmntinfo strtoull strcasecmp srandom fchown mallinfo fdatasync strnlen strptime sysconf pathconf posix_memalign memalign valloc __secure_getenv prctl)
+AC_CHECK_FUNCS(chflags getrusage llseek lseek64 open64 fstat64 getmntinfo strtoull strcasecmp srandom jrand48 fchown mallinfo fdatasync strnlen strptime sysconf pathconf posix_memalign memalign valloc __secure_getenv prctl)
 dnl
 dnl Check to see if -lsocket is required (solaris) to make something
 dnl that uses socket() to compile; this is needed for the UUID library
--- a/lib/uuid/ChangeLog	Sun Oct 22 00:14:26 2006 -0400
+++ b/lib/uuid/ChangeLog	Sun Oct 22 00:18:49 2006 -0400
@@ -1,3 +1,12 @@
+2006-10-22  Theodore Tso  <tytso@mit.edu>
+
+	* gen_uuid.c (get_random_bytes): Add in randomness based on
+		Linux's thread id (gettid) to avoid race conditions when
+		two threads try to generate uuid's at the same time.  This
+		shouldn't be an issue if /dev/urandom has proper locking
+		and is present, so this is just a failsafe.  (Addresses
+		SourceForge Bug: #1529672)
+
 2006-01-06  Theodore Ts'o  <tytso@mit.edu>
 
 	* gen_uuid.c (get_random_fd): Set the FD_CLOEXEC flag on the file
--- a/lib/uuid/gen_uuid.c	Sun Oct 22 00:14:26 2006 -0400
+++ b/lib/uuid/gen_uuid.c	Sun Oct 22 00:18:49 2006 -0400
@@ -69,12 +69,20 @@
 #ifdef HAVE_NET_IF_DL_H
 #include <net/if_dl.h>
 #endif
+#ifdef __linux__
+#include <sys/syscall.h>
+#endif
 
 #include "uuidP.h"
 
 #ifdef HAVE_SRANDOM
 #define srand(x) 	srandom(x)
 #define rand() 		random()
+#endif
+
+#if defined(__linux__) && defined(__NR_gettid) && defined(HAVE_JRAND48)
+#define DO_JRAND_MIX
+static unsigned short jrand_seed[3];
 #endif
 
 static int get_random_fd(void)
@@ -94,6 +102,11 @@
 				fcntl(fd, F_SETFD, i | FD_CLOEXEC);
 		}
 		srand((getpid() << 16) ^ getuid() ^ tv.tv_sec ^ tv.tv_usec);
+#ifdef DO_JRAND_MIX
+		jrand_seed[0] = getpid() ^ (tv.tv_sec & 0xFFFF);
+		jrand_seed[1] = getppid() ^ (tv.tv_usec & 0xFFFF);
+		jrand_seed[2] = (tv.tv_sec ^ tv.tv_usec) >> 16;
+#endif
 	}
 	/* Crank the random number generator a few times */
 	gettimeofday(&tv, 0);
@@ -112,6 +125,7 @@
 	int i, n = nbytes, fd = get_random_fd();
 	int lose_counter = 0;
 	unsigned char *cp = (unsigned char *) buf;
+	unsigned short tmp_seed[3];
 
 	if (fd >= 0) {
 		while (n > 0) {
@@ -133,6 +147,15 @@
 	 */
 	for (cp = buf, i = 0; i < nbytes; i++)
 		*cp++ ^= (rand() >> 7) & 0xFF;
+#ifdef DO_JRAND_MIX
+	memcpy(tmp_seed, jrand_seed, sizeof(tmp_seed));
+	jrand_seed[2] = jrand_seed[2] ^ syscall(__NR_gettid);
+	for (cp = buf, i = 0; i < nbytes; i++)
+		*cp++ ^= (jrand48(tmp_seed) >> 7) & 0xFF;
+	memcpy(jrand_seed, tmp_seed, 
+	       sizeof(jrand_seed)-sizeof(unsigned short));
+#endif
+
 	return;
 }
 

